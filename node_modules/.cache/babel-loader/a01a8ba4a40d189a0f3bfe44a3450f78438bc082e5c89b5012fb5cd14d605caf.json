{"ast":null,"code":"/**\n * A map of cancellable promise \"extensions\".\n *\n * Each entry value must either be a directly `cancel()`-able promise, or must\n * refer to another entry.\n *\n * When cancellation of a promise is requested, cancel\n * will check to see if the promise exists in the map. If it does, it pulls\n * the value and repeats the check. If not, it will perform the underlying\n * cancel operation.\n */\nconst promiseMap = new WeakMap();\nfunction extendCancellability(existingCancellablePromise, newPromiseToRegister) {\n  promiseMap.set(newPromiseToRegister, existingCancellablePromise);\n  return existingCancellablePromise.finally(() => {\n    promiseMap.delete(newPromiseToRegister);\n  });\n}\n/**\n * Wraps the existing `cancel()` method with logic to iteratively search for\n * the corresponding base level promise, if needed, that the core graphql client\n * knows how to cancel.\n *\n * @param client\n */\nfunction upgradeClientCancellation(client) {\n  const innerCancel = client.cancel.bind(client);\n  client.cancel = function (promise, message) {\n    const visited = new Set();\n    let targetPromise = promise;\n    while (targetPromise && promiseMap.has(targetPromise)) {\n      if (visited.has(targetPromise)) throw new Error('A cycle was detected in the modeled graphql cancellation chain. This is a bug. Please report it!');\n      visited.add(targetPromise);\n      targetPromise = promiseMap.get(targetPromise);\n    }\n    // call `innerCancel` with `targetPromise!` to defer to existing implementation\n    // on how to handle `null | undefined` or otherwise \"non-cancellable\" objects.\n    return innerCancel(targetPromise, message);\n  };\n}\nexport { extendCancellability, upgradeClientCancellation };","map":{"version":3,"names":["promiseMap","WeakMap","extendCancellability","existingCancellablePromise","newPromiseToRegister","set","finally","delete","upgradeClientCancellation","client","innerCancel","cancel","bind","promise","message","visited","Set","targetPromise","has","Error","add","get"],"sources":["/Users/yaki/digi-coin/digi-coin-app/node_modules/@aws-amplify/data-schema/src/runtime/internals/cancellation.ts"],"sourcesContent":["/**\n * A map of cancellable promise \"extensions\".\n *\n * Each entry value must either be a directly `cancel()`-able promise, or must\n * refer to another entry.\n *\n * When cancellation of a promise is requested, cancel\n * will check to see if the promise exists in the map. If it does, it pulls\n * the value and repeats the check. If not, it will perform the underlying\n * cancel operation.\n */\nconst promiseMap = new WeakMap();\nexport function extendCancellability(existingCancellablePromise, newPromiseToRegister) {\n    promiseMap.set(newPromiseToRegister, existingCancellablePromise);\n    return existingCancellablePromise.finally(() => {\n        promiseMap.delete(newPromiseToRegister);\n    });\n}\n/**\n * Wraps the existing `cancel()` method with logic to iteratively search for\n * the corresponding base level promise, if needed, that the core graphql client\n * knows how to cancel.\n *\n * @param client\n */\nexport function upgradeClientCancellation(client) {\n    const innerCancel = client.cancel.bind(client);\n    client.cancel = function (promise, message) {\n        const visited = new Set();\n        let targetPromise = promise;\n        while (targetPromise && promiseMap.has(targetPromise)) {\n            if (visited.has(targetPromise))\n                throw new Error('A cycle was detected in the modeled graphql cancellation chain. This is a bug. Please report it!');\n            visited.add(targetPromise);\n            targetPromise = promiseMap.get(targetPromise);\n        }\n        // call `innerCancel` with `targetPromise!` to defer to existing implementation\n        // on how to handle `null | undefined` or otherwise \"non-cancellable\" objects.\n        return innerCancel(targetPromise, message);\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,UAAU,GAAG,IAAIC,OAAO,EAAE;AACzB,SAASC,oBAAoBA,CAACC,0BAA0B,EAAEC,oBAAoB,EAAE;EACnFJ,UAAU,CAACK,GAAG,CAACD,oBAAoB,EAAED,0BAA0B,CAAC;EAChE,OAAOA,0BAA0B,CAACG,OAAO,CAAC,MAAM;IAC5CN,UAAU,CAACO,MAAM,CAACH,oBAAoB,CAAC;EAC/C,CAAK,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASI,yBAAyBA,CAACC,MAAM,EAAE;EAC9C,MAAMC,WAAW,GAAGD,MAAM,CAACE,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC;EAC9CA,MAAM,CAACE,MAAM,GAAG,UAAUE,OAAO,EAAEC,OAAO,EAAE;IACxC,MAAMC,OAAO,GAAG,IAAIC,GAAG,EAAE;IACzB,IAAIC,aAAa,GAAGJ,OAAO;IAC3B,OAAOI,aAAa,IAAIjB,UAAU,CAACkB,GAAG,CAACD,aAAa,CAAC,EAAE;MACnD,IAAIF,OAAO,CAACG,GAAG,CAACD,aAAa,CAAC,EAC1B,MAAM,IAAIE,KAAK,CAAC,kGAAkG,CAAC;MACvHJ,OAAO,CAACK,GAAG,CAACH,aAAa,CAAC;MAC1BA,aAAa,GAAGjB,UAAU,CAACqB,GAAG,CAACJ,aAAa,CAAC;IACzD;IACA;IACA;IACQ,OAAOP,WAAW,CAACO,aAAa,EAAEH,OAAO,CAAC;EAClD,CAAK;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}