{"ast":null,"code":"import { Observable, map, filter } from 'rxjs';\nimport { ConnectionState } from '../types/PubSub.mjs';\nimport { ReachabilityMonitor } from './ReachabilityMonitor/index.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst CONNECTION_CHANGE = {\n  KEEP_ALIVE_MISSED: {\n    keepAliveState: 'unhealthy'\n  },\n  KEEP_ALIVE: {\n    keepAliveState: 'healthy'\n  },\n  CONNECTION_ESTABLISHED: {\n    connectionState: 'connected'\n  },\n  CONNECTION_FAILED: {\n    intendedConnectionState: 'disconnected',\n    connectionState: 'disconnected'\n  },\n  CLOSING_CONNECTION: {\n    intendedConnectionState: 'disconnected'\n  },\n  OPENING_CONNECTION: {\n    intendedConnectionState: 'connected',\n    connectionState: 'connecting'\n  },\n  CLOSED: {\n    connectionState: 'disconnected'\n  },\n  ONLINE: {\n    networkState: 'connected'\n  },\n  OFFLINE: {\n    networkState: 'disconnected'\n  }\n};\nclass ConnectionStateMonitor {\n  constructor() {\n    this._networkMonitoringSubscription = undefined;\n    this._linkedConnectionState = {\n      networkState: 'connected',\n      connectionState: 'disconnected',\n      intendedConnectionState: 'disconnected',\n      keepAliveState: 'healthy'\n    };\n    // Attempt to update the state with the current actual network state\n    this._initialNetworkStateSubscription = ReachabilityMonitor().subscribe(_ref => {\n      let {\n        online\n      } = _ref;\n      this.record(online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE);\n      this._initialNetworkStateSubscription?.unsubscribe();\n    });\n    this._linkedConnectionStateObservable = new Observable(connectionStateObserver => {\n      connectionStateObserver.next(this._linkedConnectionState);\n      this._linkedConnectionStateObserver = connectionStateObserver;\n    });\n  }\n  /**\n   * Turn network state monitoring on if it isn't on already\n   */\n  enableNetworkMonitoring() {\n    // If no initial network state was discovered, stop trying\n    this._initialNetworkStateSubscription?.unsubscribe();\n    // Maintain the network state based on the reachability monitor\n    if (this._networkMonitoringSubscription === undefined) {\n      this._networkMonitoringSubscription = ReachabilityMonitor().subscribe(_ref2 => {\n        let {\n          online\n        } = _ref2;\n        this.record(online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE);\n      });\n    }\n  }\n  /**\n   * Turn network state monitoring off if it isn't off already\n   */\n  disableNetworkMonitoring() {\n    this._networkMonitoringSubscription?.unsubscribe();\n    this._networkMonitoringSubscription = undefined;\n  }\n  /**\n   * Get the observable that allows us to monitor the connection state\n   *\n   * @returns {Observable<ConnectionState>} - The observable that emits ConnectionState updates\n   */\n  get connectionStateObservable() {\n    let previous;\n    // The linked state aggregates state changes to any of the network, connection,\n    // intendedConnection and keepAliveHealth. Some states will change these independent\n    // states without changing the overall connection state.\n    // After translating from linked states to ConnectionState, then remove any duplicates\n    return this._linkedConnectionStateObservable.pipe(map(value => {\n      return this.connectionStatesTranslator(value);\n    })).pipe(filter(current => {\n      const toInclude = current !== previous;\n      previous = current;\n      return toInclude;\n    }));\n  }\n  /*\n   * Updates local connection state and emits the full state to the observer.\n   */\n  record(statusUpdates) {\n    // Maintain the network monitor\n    if (statusUpdates.intendedConnectionState === 'connected') {\n      this.enableNetworkMonitoring();\n    } else if (statusUpdates.intendedConnectionState === 'disconnected') {\n      this.disableNetworkMonitoring();\n    }\n    // Maintain the socket state\n    const newSocketStatus = {\n      ...this._linkedConnectionState,\n      ...statusUpdates\n    };\n    this._linkedConnectionState = {\n      ...newSocketStatus\n    };\n    this._linkedConnectionStateObserver?.next(this._linkedConnectionState);\n  }\n  /*\n   * Translate the ConnectionState structure into a specific ConnectionState string literal union\n   */\n  connectionStatesTranslator(_ref3) {\n    let {\n      connectionState,\n      networkState,\n      intendedConnectionState,\n      keepAliveState\n    } = _ref3;\n    if (connectionState === 'connected' && networkState === 'disconnected') return ConnectionState.ConnectedPendingNetwork;\n    if (connectionState === 'connected' && intendedConnectionState === 'disconnected') return ConnectionState.ConnectedPendingDisconnect;\n    if (connectionState === 'disconnected' && intendedConnectionState === 'connected' && networkState === 'disconnected') return ConnectionState.ConnectionDisruptedPendingNetwork;\n    if (connectionState === 'disconnected' && intendedConnectionState === 'connected') return ConnectionState.ConnectionDisrupted;\n    if (connectionState === 'connected' && keepAliveState === 'unhealthy') return ConnectionState.ConnectedPendingKeepAlive;\n    // All remaining states directly correspond to the connection state\n    if (connectionState === 'connecting') return ConnectionState.Connecting;\n    if (connectionState === 'disconnected') return ConnectionState.Disconnected;\n    return ConnectionState.Connected;\n  }\n}\nexport { CONNECTION_CHANGE, ConnectionStateMonitor };","map":{"version":3,"names":["CONNECTION_CHANGE","KEEP_ALIVE_MISSED","keepAliveState","KEEP_ALIVE","CONNECTION_ESTABLISHED","connectionState","CONNECTION_FAILED","intendedConnectionState","CLOSING_CONNECTION","OPENING_CONNECTION","CLOSED","ONLINE","networkState","OFFLINE","ConnectionStateMonitor","constructor","_networkMonitoringSubscription","undefined","_linkedConnectionState","_initialNetworkStateSubscription","ReachabilityMonitor","subscribe","_ref","online","record","unsubscribe","_linkedConnectionStateObservable","Observable","connectionStateObserver","next","_linkedConnectionStateObserver","enableNetworkMonitoring","_ref2","disableNetworkMonitoring","connectionStateObservable","previous","pipe","map","value","connectionStatesTranslator","filter","current","toInclude","statusUpdates","newSocketStatus","_ref3","ConnectionState","ConnectedPendingNetwork","ConnectedPendingDisconnect","ConnectionDisruptedPendingNetwork","ConnectionDisrupted","ConnectedPendingKeepAlive","Connecting","Disconnected","Connected"],"sources":["/Users/yaki/digi-coin/digi-coin-app/node_modules/@aws-amplify/api-graphql/src/utils/ConnectionStateMonitor.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Observable, filter, map } from 'rxjs';\nimport { ConnectionState } from '../types/PubSub';\nimport { ReachabilityMonitor } from './ReachabilityMonitor';\nexport const CONNECTION_CHANGE = {\n    KEEP_ALIVE_MISSED: { keepAliveState: 'unhealthy' },\n    KEEP_ALIVE: { keepAliveState: 'healthy' },\n    CONNECTION_ESTABLISHED: { connectionState: 'connected' },\n    CONNECTION_FAILED: {\n        intendedConnectionState: 'disconnected',\n        connectionState: 'disconnected',\n    },\n    CLOSING_CONNECTION: { intendedConnectionState: 'disconnected' },\n    OPENING_CONNECTION: {\n        intendedConnectionState: 'connected',\n        connectionState: 'connecting',\n    },\n    CLOSED: { connectionState: 'disconnected' },\n    ONLINE: { networkState: 'connected' },\n    OFFLINE: { networkState: 'disconnected' },\n};\nexport class ConnectionStateMonitor {\n    constructor() {\n        this._networkMonitoringSubscription = undefined;\n        this._linkedConnectionState = {\n            networkState: 'connected',\n            connectionState: 'disconnected',\n            intendedConnectionState: 'disconnected',\n            keepAliveState: 'healthy',\n        };\n        // Attempt to update the state with the current actual network state\n        this._initialNetworkStateSubscription = ReachabilityMonitor().subscribe(({ online }) => {\n            this.record(online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE);\n            this._initialNetworkStateSubscription?.unsubscribe();\n        });\n        this._linkedConnectionStateObservable =\n            new Observable(connectionStateObserver => {\n                connectionStateObserver.next(this._linkedConnectionState);\n                this._linkedConnectionStateObserver = connectionStateObserver;\n            });\n    }\n    /**\n     * Turn network state monitoring on if it isn't on already\n     */\n    enableNetworkMonitoring() {\n        // If no initial network state was discovered, stop trying\n        this._initialNetworkStateSubscription?.unsubscribe();\n        // Maintain the network state based on the reachability monitor\n        if (this._networkMonitoringSubscription === undefined) {\n            this._networkMonitoringSubscription = ReachabilityMonitor().subscribe(({ online }) => {\n                this.record(online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE);\n            });\n        }\n    }\n    /**\n     * Turn network state monitoring off if it isn't off already\n     */\n    disableNetworkMonitoring() {\n        this._networkMonitoringSubscription?.unsubscribe();\n        this._networkMonitoringSubscription = undefined;\n    }\n    /**\n     * Get the observable that allows us to monitor the connection state\n     *\n     * @returns {Observable<ConnectionState>} - The observable that emits ConnectionState updates\n     */\n    get connectionStateObservable() {\n        let previous;\n        // The linked state aggregates state changes to any of the network, connection,\n        // intendedConnection and keepAliveHealth. Some states will change these independent\n        // states without changing the overall connection state.\n        // After translating from linked states to ConnectionState, then remove any duplicates\n        return this._linkedConnectionStateObservable\n            .pipe(map(value => {\n            return this.connectionStatesTranslator(value);\n        }))\n            .pipe(filter(current => {\n            const toInclude = current !== previous;\n            previous = current;\n            return toInclude;\n        }));\n    }\n    /*\n     * Updates local connection state and emits the full state to the observer.\n     */\n    record(statusUpdates) {\n        // Maintain the network monitor\n        if (statusUpdates.intendedConnectionState === 'connected') {\n            this.enableNetworkMonitoring();\n        }\n        else if (statusUpdates.intendedConnectionState === 'disconnected') {\n            this.disableNetworkMonitoring();\n        }\n        // Maintain the socket state\n        const newSocketStatus = {\n            ...this._linkedConnectionState,\n            ...statusUpdates,\n        };\n        this._linkedConnectionState = { ...newSocketStatus };\n        this._linkedConnectionStateObserver?.next(this._linkedConnectionState);\n    }\n    /*\n     * Translate the ConnectionState structure into a specific ConnectionState string literal union\n     */\n    connectionStatesTranslator({ connectionState, networkState, intendedConnectionState, keepAliveState, }) {\n        if (connectionState === 'connected' && networkState === 'disconnected')\n            return ConnectionState.ConnectedPendingNetwork;\n        if (connectionState === 'connected' &&\n            intendedConnectionState === 'disconnected')\n            return ConnectionState.ConnectedPendingDisconnect;\n        if (connectionState === 'disconnected' &&\n            intendedConnectionState === 'connected' &&\n            networkState === 'disconnected')\n            return ConnectionState.ConnectionDisruptedPendingNetwork;\n        if (connectionState === 'disconnected' &&\n            intendedConnectionState === 'connected')\n            return ConnectionState.ConnectionDisrupted;\n        if (connectionState === 'connected' && keepAliveState === 'unhealthy')\n            return ConnectionState.ConnectedPendingKeepAlive;\n        // All remaining states directly correspond to the connection state\n        if (connectionState === 'connecting')\n            return ConnectionState.Connecting;\n        if (connectionState === 'disconnected')\n            return ConnectionState.Disconnected;\n        return ConnectionState.Connected;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}