{"ast":null,"code":"import { RECONNECT_INTERVAL, RECONNECT_DELAY } from '../Providers/constants.mjs';\nvar ReconnectEvent;\n(function (ReconnectEvent) {\n  ReconnectEvent[\"START_RECONNECT\"] = \"START_RECONNECT\";\n  ReconnectEvent[\"HALT_RECONNECT\"] = \"HALT_RECONNECT\";\n})(ReconnectEvent || (ReconnectEvent = {}));\n/**\n * Captures the reconnect event logic used to determine when to reconnect to PubSub providers.\n *   Reconnect attempts are delayed by 5 seconds to let the interface settle.\n *   Attempting to reconnect only once creates unrecoverable states when the network state isn't\n *   supported by the browser, so this keeps retrying every minute until halted.\n */\nclass ReconnectionMonitor {\n  constructor() {\n    this.reconnectObservers = [];\n  }\n  /**\n   * Add reconnect observer to the list of observers to alert on reconnect\n   */\n  addObserver(reconnectObserver) {\n    this.reconnectObservers.push(reconnectObserver);\n  }\n  /**\n   * Given a reconnect event, start the appropriate behavior\n   */\n  record(event) {\n    if (event === ReconnectEvent.START_RECONNECT) {\n      // If the reconnection hasn't been started\n      if (this.reconnectSetTimeoutId === undefined && this.reconnectIntervalId === undefined) {\n        this.reconnectSetTimeoutId = setTimeout(() => {\n          // Reconnect now\n          this._triggerReconnect();\n          // Retry reconnect every periodically until it works\n          this.reconnectIntervalId = setInterval(() => {\n            this._triggerReconnect();\n          }, RECONNECT_INTERVAL);\n        }, RECONNECT_DELAY);\n      }\n    }\n    if (event === ReconnectEvent.HALT_RECONNECT) {\n      if (this.reconnectIntervalId) {\n        clearInterval(this.reconnectIntervalId);\n        this.reconnectIntervalId = undefined;\n      }\n      if (this.reconnectSetTimeoutId) {\n        clearTimeout(this.reconnectSetTimeoutId);\n        this.reconnectSetTimeoutId = undefined;\n      }\n    }\n  }\n  /**\n   * Complete all reconnect observers\n   */\n  close() {\n    this.reconnectObservers.forEach(reconnectObserver => {\n      reconnectObserver.complete?.();\n    });\n  }\n  _triggerReconnect() {\n    this.reconnectObservers.forEach(reconnectObserver => {\n      reconnectObserver.next?.();\n    });\n  }\n}\nexport { ReconnectEvent, ReconnectionMonitor };","map":{"version":3,"names":["ReconnectEvent","ReconnectionMonitor","constructor","reconnectObservers","addObserver","reconnectObserver","push","record","event","START_RECONNECT","reconnectSetTimeoutId","undefined","reconnectIntervalId","setTimeout","_triggerReconnect","setInterval","RECONNECT_INTERVAL","RECONNECT_DELAY","HALT_RECONNECT","clearInterval","clearTimeout","close","forEach","complete","next"],"sources":["/Users/yaki/digi-coin/digi-coin-app/node_modules/@aws-amplify/api-graphql/src/utils/ReconnectionMonitor.ts"],"sourcesContent":["import { RECONNECT_DELAY, RECONNECT_INTERVAL } from '../Providers/constants';\nexport var ReconnectEvent;\n(function (ReconnectEvent) {\n    ReconnectEvent[\"START_RECONNECT\"] = \"START_RECONNECT\";\n    ReconnectEvent[\"HALT_RECONNECT\"] = \"HALT_RECONNECT\";\n})(ReconnectEvent || (ReconnectEvent = {}));\n/**\n * Captures the reconnect event logic used to determine when to reconnect to PubSub providers.\n *   Reconnect attempts are delayed by 5 seconds to let the interface settle.\n *   Attempting to reconnect only once creates unrecoverable states when the network state isn't\n *   supported by the browser, so this keeps retrying every minute until halted.\n */\nexport class ReconnectionMonitor {\n    constructor() {\n        this.reconnectObservers = [];\n    }\n    /**\n     * Add reconnect observer to the list of observers to alert on reconnect\n     */\n    addObserver(reconnectObserver) {\n        this.reconnectObservers.push(reconnectObserver);\n    }\n    /**\n     * Given a reconnect event, start the appropriate behavior\n     */\n    record(event) {\n        if (event === ReconnectEvent.START_RECONNECT) {\n            // If the reconnection hasn't been started\n            if (this.reconnectSetTimeoutId === undefined &&\n                this.reconnectIntervalId === undefined) {\n                this.reconnectSetTimeoutId = setTimeout(() => {\n                    // Reconnect now\n                    this._triggerReconnect();\n                    // Retry reconnect every periodically until it works\n                    this.reconnectIntervalId = setInterval(() => {\n                        this._triggerReconnect();\n                    }, RECONNECT_INTERVAL);\n                }, RECONNECT_DELAY);\n            }\n        }\n        if (event === ReconnectEvent.HALT_RECONNECT) {\n            if (this.reconnectIntervalId) {\n                clearInterval(this.reconnectIntervalId);\n                this.reconnectIntervalId = undefined;\n            }\n            if (this.reconnectSetTimeoutId) {\n                clearTimeout(this.reconnectSetTimeoutId);\n                this.reconnectSetTimeoutId = undefined;\n            }\n        }\n    }\n    /**\n     * Complete all reconnect observers\n     */\n    close() {\n        this.reconnectObservers.forEach(reconnectObserver => {\n            reconnectObserver.complete?.();\n        });\n    }\n    _triggerReconnect() {\n        this.reconnectObservers.forEach(reconnectObserver => {\n            reconnectObserver.next?.();\n        });\n    }\n}\n"],"mappings":";AACU,IAACA,cAAA;AACX,CAAC,UAAUA,cAAc,EAAE;EACvBA,cAAc,CAAC,iBAAiB,CAAC,GAAG,iBAAiB;EACrDA,cAAc,CAAC,gBAAgB,CAAC,GAAG,gBAAgB;AACvD,CAAC,EAAEA,cAAc,KAAKA,cAAc,GAAG,EAAE,CAAC,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,mBAAmB,CAAC;EAC7BC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,kBAAkB,GAAG,EAAE;EACpC;EACA;AACA;AACA;EACIC,WAAWA,CAACC,iBAAiB,EAAE;IAC3B,IAAI,CAACF,kBAAkB,CAACG,IAAI,CAACD,iBAAiB,CAAC;EACvD;EACA;AACA;AACA;EACIE,MAAMA,CAACC,KAAK,EAAE;IACV,IAAIA,KAAK,KAAKR,cAAc,CAACS,eAAe,EAAE;MACtD;MACY,IAAI,IAAI,CAACC,qBAAqB,KAAKC,SAAS,IACxC,IAAI,CAACC,mBAAmB,KAAKD,SAAS,EAAE;QACxC,IAAI,CAACD,qBAAqB,GAAGG,UAAU,CAAC,MAAM;UAC9D;UACoB,IAAI,CAACC,iBAAiB,EAAE;UAC5C;UACoB,IAAI,CAACF,mBAAmB,GAAGG,WAAW,CAAC,MAAM;YACzC,IAAI,CAACD,iBAAiB,EAAE;UAChD,CAAqB,EAAEE,kBAAkB,CAAC;QAC1C,CAAiB,EAAEC,eAAe,CAAC;MACnC;IACA;IACQ,IAAIT,KAAK,KAAKR,cAAc,CAACkB,cAAc,EAAE;MACzC,IAAI,IAAI,CAACN,mBAAmB,EAAE;QAC1BO,aAAa,CAAC,IAAI,CAACP,mBAAmB,CAAC;QACvC,IAAI,CAACA,mBAAmB,GAAGD,SAAS;MACpD;MACY,IAAI,IAAI,CAACD,qBAAqB,EAAE;QAC5BU,YAAY,CAAC,IAAI,CAACV,qBAAqB,CAAC;QACxC,IAAI,CAACA,qBAAqB,GAAGC,SAAS;MACtD;IACA;EACA;EACA;AACA;AACA;EACIU,KAAKA,CAAA,EAAG;IACJ,IAAI,CAAClB,kBAAkB,CAACmB,OAAO,CAACjB,iBAAiB,IAAI;MACjDA,iBAAiB,CAACkB,QAAQ,IAAI;IAC1C,CAAS,CAAC;EACV;EACIT,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACX,kBAAkB,CAACmB,OAAO,CAACjB,iBAAiB,IAAI;MACjDA,iBAAiB,CAACmB,IAAI,IAAI;IACtC,CAAS,CAAC;EACV;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}