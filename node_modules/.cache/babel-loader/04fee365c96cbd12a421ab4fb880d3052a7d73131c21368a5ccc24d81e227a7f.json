{"ast":null,"code":"import { Observable } from 'rxjs';\nimport { resolvePKFields } from '../../utils/resolvePKFields.mjs';\nimport { findIndexByFields } from '../../utils/findIndexByFields.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nfunction observeQueryFactory(models, model) {\n  const {\n    name\n  } = model;\n  const observeQuery = arg => new Observable(subscriber => {\n    // what we'll be sending to our subscribers\n    const items = [];\n    // To enqueue subscription messages while we collect our initial\n    // result set.\n    const messageQueue = [];\n    // operation to take when message(s) arrive.\n    // this operation will be swapped out once initial \"sync\" is complete\n    // to immediately ingest messsages.\n    let receiveMessages = (...messages) => {\n      return messageQueue.push(...messages);\n    };\n    // start subscriptions\n    const onCreateSub = models[name].onCreate(arg).subscribe({\n      next(item) {\n        receiveMessages({\n          item,\n          type: 'create'\n        });\n      },\n      error(error) {\n        subscriber.error({\n          type: 'onCreate',\n          error\n        });\n      }\n    });\n    const onUpdateSub = models[name].onUpdate(arg).subscribe({\n      next(item) {\n        receiveMessages({\n          item,\n          type: 'update'\n        });\n      },\n      error(error) {\n        subscriber.error({\n          type: 'onUpdate',\n          error\n        });\n      }\n    });\n    const onDeleteSub = models[name].onDelete(arg).subscribe({\n      next(item) {\n        receiveMessages({\n          item,\n          type: 'delete'\n        });\n      },\n      error(error) {\n        subscriber.error({\n          type: 'onDelete',\n          error\n        });\n      }\n    });\n    // consumes a list of messages and sends a snapshot\n    function ingestMessages(messages) {\n      for (const message of messages) {\n        const idx = findIndexByFields(message.item, items, pkFields);\n        switch (message.type) {\n          case 'create':\n            if (idx < 0) items.push(message.item);\n            break;\n          case 'update':\n            if (idx >= 0) items[idx] = message.item;\n            break;\n          case 'delete':\n            if (idx >= 0) items.splice(idx, 1);\n            break;\n          default:\n            console.error('Unrecognized message in observeQuery.', message);\n        }\n      }\n      subscriber.next({\n        items,\n        isSynced: true\n      });\n    }\n    const pkFields = resolvePKFields(model);\n    // initial results\n    (async () => {\n      let firstPage = true;\n      let nextToken = null;\n      while (!subscriber.closed && (firstPage || nextToken)) {\n        firstPage = false;\n        const {\n          data: page,\n          errors,\n          nextToken: _nextToken\n        } = await models[name].list({\n          ...arg,\n          nextToken\n        });\n        nextToken = _nextToken;\n        items.push(...page);\n        // if there are no more pages and no items we already know about\n        // that need to be merged in from sub, we're \"synced\"\n        const isSynced = messageQueue.length === 0 && (nextToken === null || nextToken === undefined);\n        subscriber.next({\n          items,\n          isSynced\n        });\n        if (Array.isArray(errors)) {\n          for (const error of errors) {\n            subscriber.error(error);\n          }\n        }\n      }\n      // play through the queue\n      if (messageQueue.length > 0) {\n        ingestMessages(messageQueue);\n      }\n      // switch the queue to write directly to the items collection\n      receiveMessages = (...messages) => {\n        ingestMessages(messages);\n        return items.length;\n      };\n    })();\n    // when subscriber unsubscribes, tear down internal subs\n    return () => {\n      // 1. tear down internal subs\n      onCreateSub.unsubscribe();\n      onUpdateSub.unsubscribe();\n      onDeleteSub.unsubscribe();\n      // 2. there is no need to explicitly stop paging. instead, we\n      // just check `subscriber.closed` above before fetching each page.\n    };\n  });\n  return observeQuery;\n}\nexport { observeQueryFactory };","map":{"version":3,"names":["observeQueryFactory","models","model","name","observeQuery","arg","Observable","subscriber","items","messageQueue","receiveMessages","messages","push","onCreateSub","onCreate","subscribe","next","item","type","error","onUpdateSub","onUpdate","onDeleteSub","onDelete","ingestMessages","message","idx","findIndexByFields","pkFields","splice","console","isSynced","resolvePKFields","firstPage","nextToken","closed","data","page","errors","_nextToken","list","length","undefined","Array","isArray","unsubscribe"],"sources":["/Users/yaki/digi-coin/digi-coin-app/node_modules/@aws-amplify/data-schema/src/runtime/internals/operations/observeQuery.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Observable } from 'rxjs';\nimport { findIndexByFields, resolvePKFields } from '../../utils';\nexport function observeQueryFactory(models, model) {\n    const { name } = model;\n    const observeQuery = (arg) => new Observable((subscriber) => {\n        // what we'll be sending to our subscribers\n        const items = [];\n        // To enqueue subscription messages while we collect our initial\n        // result set.\n        const messageQueue = [];\n        // operation to take when message(s) arrive.\n        // this operation will be swapped out once initial \"sync\" is complete\n        // to immediately ingest messsages.\n        let receiveMessages = (...messages) => {\n            return messageQueue.push(...messages);\n        };\n        // start subscriptions\n        const onCreateSub = models[name].onCreate(arg).subscribe({\n            next(item) {\n                receiveMessages({ item, type: 'create' });\n            },\n            error(error) {\n                subscriber.error({ type: 'onCreate', error });\n            },\n        });\n        const onUpdateSub = models[name].onUpdate(arg).subscribe({\n            next(item) {\n                receiveMessages({ item, type: 'update' });\n            },\n            error(error) {\n                subscriber.error({ type: 'onUpdate', error });\n            },\n        });\n        const onDeleteSub = models[name].onDelete(arg).subscribe({\n            next(item) {\n                receiveMessages({ item, type: 'delete' });\n            },\n            error(error) {\n                subscriber.error({ type: 'onDelete', error });\n            },\n        });\n        // consumes a list of messages and sends a snapshot\n        function ingestMessages(messages) {\n            for (const message of messages) {\n                const idx = findIndexByFields(message.item, items, pkFields);\n                switch (message.type) {\n                    case 'create':\n                        if (idx < 0)\n                            items.push(message.item);\n                        break;\n                    case 'update':\n                        if (idx >= 0)\n                            items[idx] = message.item;\n                        break;\n                    case 'delete':\n                        if (idx >= 0)\n                            items.splice(idx, 1);\n                        break;\n                    default:\n                        console.error('Unrecognized message in observeQuery.', message);\n                }\n            }\n            subscriber.next({\n                items,\n                isSynced: true,\n            });\n        }\n        const pkFields = resolvePKFields(model);\n        // initial results\n        (async () => {\n            let firstPage = true;\n            let nextToken = null;\n            while (!subscriber.closed && (firstPage || nextToken)) {\n                firstPage = false;\n                const { data: page, errors, nextToken: _nextToken, } = await models[name].list({ ...arg, nextToken });\n                nextToken = _nextToken;\n                items.push(...page);\n                // if there are no more pages and no items we already know about\n                // that need to be merged in from sub, we're \"synced\"\n                const isSynced = messageQueue.length === 0 &&\n                    (nextToken === null || nextToken === undefined);\n                subscriber.next({\n                    items,\n                    isSynced,\n                });\n                if (Array.isArray(errors)) {\n                    for (const error of errors) {\n                        subscriber.error(error);\n                    }\n                }\n            }\n            // play through the queue\n            if (messageQueue.length > 0) {\n                ingestMessages(messageQueue);\n            }\n            // switch the queue to write directly to the items collection\n            receiveMessages = (...messages) => {\n                ingestMessages(messages);\n                return items.length;\n            };\n        })();\n        // when subscriber unsubscribes, tear down internal subs\n        return () => {\n            // 1. tear down internal subs\n            onCreateSub.unsubscribe();\n            onUpdateSub.unsubscribe();\n            onDeleteSub.unsubscribe();\n            // 2. there is no need to explicitly stop paging. instead, we\n            // just check `subscriber.closed` above before fetching each page.\n        };\n    });\n    return observeQuery;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}