{"ast":null,"code":"import { GraphQLAPI } from '../GraphQLAPI.mjs';\nimport { getInternals } from '../types/index.mjs';\n\n/**\n * Invokes graphql operations against a graphql service, providing correct input and\n * output types if Amplify-generated graphql from a recent version of the CLI/codegen\n * are used *or* correct typing is provided via the type argument.\n *\n * Amplify-generated \"branded\" graphql queries will look similar to this:\n *\n * ```ts\n *                               //\n *                               // |-- branding\n *                               // v\n * export const getModel = `...` as GeneratedQuery<\n * \tGetModelQueryVariables,\n * \tGetModelQuery\n * >;\n * ```\n *\n * If this branding is not in your generated graphql, update to a newer version of\n * CLI/codegen and regenerate your graphql using `amplify codegen`.\n *\n * ## Using Amplify-generated graphql\n *\n * ```ts\n * import * as queries from './graphql/queries';\n *\n * //\n * //    |-- correctly typed graphql response containing a Widget\n * //    v\n * const queryResult = await graphql({\n * \tquery: queries.getWidget,\n * \tvariables: {\n * \t\tid: \"abc\", // <-- type hinted/enforced\n * \t},\n * });\n *\n * //\n * //    |-- a correctly typed Widget\n * //    v\n * const fetchedWidget = queryResult.data?.getWidget!;\n * ```\n *\n * ## Custom input + result types\n *\n * To provide input types (`variables`) and result types:\n *\n * ```ts\n * type GetById_NameOnly = {\n * \tvariables: {\n * \t\tid: string\n * \t},\n * \tresult: Promise<{\n * \t\tdata: { getWidget: { name: string } }\n * \t}>\n * }\n *\n * //\n * //    |-- type is GetById_NameOnly[\"result\"]\n * //    v\n * const result = graphql<GetById_NameOnly>({\n * \tquery: \"...\",\n * \tvariables: { id: \"abc\" }  // <-- type of GetById_NameOnly[\"variables\"]\n * });\n * ```\n *\n * ## Custom result type only\n *\n * To specify result types only, use a type that is *not* in the `{variables, result}` shape:\n *\n * ```ts\n * type MyResultType = Promise<{\n * \tdata: {\n * \t\tgetWidget: { name: string }\n * \t}\n * }>\n *\n * //\n * //    |-- type is MyResultType\n * //    v\n * const result = graphql<MyResultType>({query: \"...\"});\n * ```\n *\n * @param options\n * @param additionalHeaders\n */\nfunction graphql(options, additionalHeaders) {\n  // inject client-level auth\n  const internals = getInternals(this);\n  /**\n   * The custom `endpoint` specific to the client\n   */\n  const clientEndpoint = internals.endpoint;\n  /**\n   * The `authMode` specific to the client.\n   */\n  const clientAuthMode = internals.authMode;\n  /**\n   * The `apiKey` specific to the client.\n   */\n  const clientApiKey = internals.apiKey;\n  /**\n   * The most specific `authMode` wins. Setting an `endpoint` value without also\n   * setting an `authMode` value is invalid. This helps to prevent customers apps\n   * from unexpectedly sending auth details to endpoints the auth details do not\n   * belong to.\n   *\n   * This is especially pronounced for `apiKey`. When both an `endpoint` *and*\n   * `authMode: 'apiKey'` are provided, an explicit `apiKey` override is required\n   * to prevent inadvertent sending of an API's `apiKey` to an endpoint is does\n   * not belong to.\n   */\n  options.authMode = options.authMode || clientAuthMode;\n  options.apiKey = options.apiKey ?? clientApiKey;\n  options.authToken = options.authToken || internals.authToken;\n  if (clientEndpoint && options.authMode === 'apiKey' && !options.apiKey) {\n    throw new Error(\"graphql() requires an explicit `apiKey` for a custom `endpoint` when `authMode = 'apiKey'`.\");\n  }\n  const headers = additionalHeaders || internals.headers;\n  /**\n   * The correctness of these typings depends on correct string branding or overrides.\n   * Neither of these can actually be validated at runtime. Hence, we don't perform\n   * any validation or type-guarding here.\n   */\n  const result = GraphQLAPI.graphql(\n  // TODO: move V6Client back into this package?\n  internals.amplify, {\n    ...options,\n    endpoint: clientEndpoint\n  }, headers);\n  return result;\n}\n/**\n * Cancels an inflight request. Only applicable for graphql queries and mutations\n * @param {any} request - request to cancel\n * @returns - A boolean indicating if the request was cancelled\n */\nfunction cancel(promise, message) {\n  return GraphQLAPI.cancel(promise, message);\n}\n/**\n * Checks to see if an error thrown is from an api request cancellation\n * @param {any} error - Any error\n * @returns - A boolean indicating if the error was from an api request cancellation\n */\nfunction isCancelError(error) {\n  return GraphQLAPI.isCancelError(error);\n}\nexport { cancel, graphql, isCancelError };","map":{"version":3,"names":["graphql","options","additionalHeaders","internals","getInternals","clientEndpoint","endpoint","clientAuthMode","authMode","clientApiKey","apiKey","authToken","Error","headers","result","GraphQLAPI","amplify","cancel","promise","message","isCancelError","error"],"sources":["/Users/yaki/digi-coin/digi-coin-app/node_modules/@aws-amplify/api-graphql/src/internals/v6.ts"],"sourcesContent":["import { GraphQLAPI } from '../GraphQLAPI';\nimport { getInternals, } from '../types';\n/**\n * Invokes graphql operations against a graphql service, providing correct input and\n * output types if Amplify-generated graphql from a recent version of the CLI/codegen\n * are used *or* correct typing is provided via the type argument.\n *\n * Amplify-generated \"branded\" graphql queries will look similar to this:\n *\n * ```ts\n *                               //\n *                               // |-- branding\n *                               // v\n * export const getModel = `...` as GeneratedQuery<\n * \tGetModelQueryVariables,\n * \tGetModelQuery\n * >;\n * ```\n *\n * If this branding is not in your generated graphql, update to a newer version of\n * CLI/codegen and regenerate your graphql using `amplify codegen`.\n *\n * ## Using Amplify-generated graphql\n *\n * ```ts\n * import * as queries from './graphql/queries';\n *\n * //\n * //    |-- correctly typed graphql response containing a Widget\n * //    v\n * const queryResult = await graphql({\n * \tquery: queries.getWidget,\n * \tvariables: {\n * \t\tid: \"abc\", // <-- type hinted/enforced\n * \t},\n * });\n *\n * //\n * //    |-- a correctly typed Widget\n * //    v\n * const fetchedWidget = queryResult.data?.getWidget!;\n * ```\n *\n * ## Custom input + result types\n *\n * To provide input types (`variables`) and result types:\n *\n * ```ts\n * type GetById_NameOnly = {\n * \tvariables: {\n * \t\tid: string\n * \t},\n * \tresult: Promise<{\n * \t\tdata: { getWidget: { name: string } }\n * \t}>\n * }\n *\n * //\n * //    |-- type is GetById_NameOnly[\"result\"]\n * //    v\n * const result = graphql<GetById_NameOnly>({\n * \tquery: \"...\",\n * \tvariables: { id: \"abc\" }  // <-- type of GetById_NameOnly[\"variables\"]\n * });\n * ```\n *\n * ## Custom result type only\n *\n * To specify result types only, use a type that is *not* in the `{variables, result}` shape:\n *\n * ```ts\n * type MyResultType = Promise<{\n * \tdata: {\n * \t\tgetWidget: { name: string }\n * \t}\n * }>\n *\n * //\n * //    |-- type is MyResultType\n * //    v\n * const result = graphql<MyResultType>({query: \"...\"});\n * ```\n *\n * @param options\n * @param additionalHeaders\n */\nexport function graphql(options, additionalHeaders) {\n    // inject client-level auth\n    const internals = getInternals(this);\n    /**\n     * The custom `endpoint` specific to the client\n     */\n    const clientEndpoint = internals.endpoint;\n    /**\n     * The `authMode` specific to the client.\n     */\n    const clientAuthMode = internals.authMode;\n    /**\n     * The `apiKey` specific to the client.\n     */\n    const clientApiKey = internals.apiKey;\n    /**\n     * The most specific `authMode` wins. Setting an `endpoint` value without also\n     * setting an `authMode` value is invalid. This helps to prevent customers apps\n     * from unexpectedly sending auth details to endpoints the auth details do not\n     * belong to.\n     *\n     * This is especially pronounced for `apiKey`. When both an `endpoint` *and*\n     * `authMode: 'apiKey'` are provided, an explicit `apiKey` override is required\n     * to prevent inadvertent sending of an API's `apiKey` to an endpoint is does\n     * not belong to.\n     */\n    options.authMode = options.authMode || clientAuthMode;\n    options.apiKey = options.apiKey ?? clientApiKey;\n    options.authToken = options.authToken || internals.authToken;\n    if (clientEndpoint && options.authMode === 'apiKey' && !options.apiKey) {\n        throw new Error(\"graphql() requires an explicit `apiKey` for a custom `endpoint` when `authMode = 'apiKey'`.\");\n    }\n    const headers = additionalHeaders || internals.headers;\n    /**\n     * The correctness of these typings depends on correct string branding or overrides.\n     * Neither of these can actually be validated at runtime. Hence, we don't perform\n     * any validation or type-guarding here.\n     */\n    const result = GraphQLAPI.graphql(\n    // TODO: move V6Client back into this package?\n    internals.amplify, {\n        ...options,\n        endpoint: clientEndpoint,\n    }, headers);\n    return result;\n}\n/**\n * Cancels an inflight request. Only applicable for graphql queries and mutations\n * @param {any} request - request to cancel\n * @returns - A boolean indicating if the request was cancelled\n */\nexport function cancel(promise, message) {\n    return GraphQLAPI.cancel(promise, message);\n}\n/**\n * Checks to see if an error thrown is from an api request cancellation\n * @param {any} error - Any error\n * @returns - A boolean indicating if the error was from an api request cancellation\n */\nexport function isCancelError(error) {\n    return GraphQLAPI.isCancelError(error);\n}\n"],"mappings":";;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,OAAOA,CAACC,OAAO,EAAEC,iBAAiB,EAAE;EACpD;EACI,MAAMC,SAAS,GAAGC,YAAY,CAAC,IAAI,CAAC;EACxC;AACA;AACA;EACI,MAAMC,cAAc,GAAGF,SAAS,CAACG,QAAQ;EAC7C;AACA;AACA;EACI,MAAMC,cAAc,GAAGJ,SAAS,CAACK,QAAQ;EAC7C;AACA;AACA;EACI,MAAMC,YAAY,GAAGN,SAAS,CAACO,MAAM;EACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIT,OAAO,CAACO,QAAQ,GAAGP,OAAO,CAACO,QAAQ,IAAID,cAAc;EACrDN,OAAO,CAACS,MAAM,GAAGT,OAAO,CAACS,MAAM,IAAID,YAAY;EAC/CR,OAAO,CAACU,SAAS,GAAGV,OAAO,CAACU,SAAS,IAAIR,SAAS,CAACQ,SAAS;EAC5D,IAAIN,cAAc,IAAIJ,OAAO,CAACO,QAAQ,KAAK,QAAQ,IAAI,CAACP,OAAO,CAACS,MAAM,EAAE;IACpE,MAAM,IAAIE,KAAK,CAAC,6FAA6F,CAAC;EACtH;EACI,MAAMC,OAAO,GAAGX,iBAAiB,IAAIC,SAAS,CAACU,OAAO;EAC1D;AACA;AACA;AACA;AACA;EACI,MAAMC,MAAM,GAAGC,UAAU,CAACf,OAAO;EACrC;EACIG,SAAS,CAACa,OAAO,EAAE;IACf,GAAGf,OAAO;IACVK,QAAQ,EAAED;EAClB,CAAK,EAAEQ,OAAO,CAAC;EACX,OAAOC,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,MAAMA,CAACC,OAAO,EAAEC,OAAO,EAAE;EACrC,OAAOJ,UAAU,CAACE,MAAM,CAACC,OAAO,EAAEC,OAAO,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,aAAaA,CAACC,KAAK,EAAE;EACjC,OAAON,UAAU,CAACK,aAAa,CAACC,KAAK,CAAC;AAC1C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}